import type { ColorAdjustmentStrategy, ColorKeyOrString, Padding, PointStyle, TextInfoUnkeyed } from "./deps.ts";
import type { CsvCellFormatterFunc, StyleFuncBoolean, StyleFuncColorKeyOrString, StyleFuncString, StyleFuncUpperLabel } from "./style_func_types.ts";
import type { DataLabelPositionOffset, LegendItemsSource, LegendPosition, PaletteLogic } from "./types.ts";
export type MergedChartStyle = {
    alreadyScaledValue: number;
    text: {
        xTextAxisTickLabels: TextInfoUnkeyed;
        xScaleAxisTickLabels: TextInfoUnkeyed;
        xTextAxisLabel: TextInfoUnkeyed;
        xScaleAxisLabel: TextInfoUnkeyed;
        yTextAxisTickLabels: TextInfoUnkeyed;
        yScaleAxisTickLabels: TextInfoUnkeyed;
        yTextAxisLabel: TextInfoUnkeyed;
        yScaleAxisLabel: TextInfoUnkeyed;
        colGroupLabels: TextInfoUnkeyed;
        dataLabels: TextInfoUnkeyed;
        arrowLabels: TextInfoUnkeyed;
        cascadeArrowUpperLabels: TextInfoUnkeyed;
        sankeyLabels: TextInfoUnkeyed;
    };
    legendItemsSource: LegendItemsSource;
    sankey: {
        labelBottomGap: number;
        labelRightGap: number;
        itemGap: number;
        itemWidth: number;
    };
    xTextAxis: {
        verticalTickLabels: boolean;
        maxVerticalTickLabelHeightAsPctOfChart: number;
        showGrid: boolean;
        paddingLeft: number;
        paddingRight: number;
        labelGap: number;
        tickHeight: number;
        tickLabelGap: number;
        tickLabelPaddingX: number;
        colGroupGap: number;
        colGroupLabelPaddingX: number;
        colGroupBracketGapTop: number;
        colGroupBracketGapBottom: number;
        colGroupBracketPaddingX: number;
        colGroupBracketTickHeight: number;
    };
    xScaleAxis: {
        max: number | "auto";
        min: number | "auto";
        showGrid: boolean;
        labelGap: number;
        tickHeight: number;
        tickLabelGap: number;
        tickLabelFormatter: (v: number) => string;
    };
    yTextAxis: {
        colHeight: number;
        showGrid: boolean;
        paddingTop: number;
        paddingBottom: number;
        labelGap: number;
        tickWidth: number;
        tickLabelGap: number;
        logicTickLabelWidth: "auto" | "fixed";
        logicColGroupLabelWidth: "auto" | "fixed";
        maxTickLabelWidthAsPctOfChart: number;
        maxColGroupLabelWidthAsPctOfChart: number;
        colGroupGap: number;
        colGroupBracketGapLeft: number;
        colGroupBracketGapRight: number;
        colGroupBracketPaddingY: number;
        colGroupBracketTickWidth: number;
        verticalColGroupLabels: boolean;
    };
    yScaleAxis: {
        max: number | "auto";
        min: number | "auto";
        showGrid: boolean;
        labelGap: number;
        tickWidth: number;
        tickLabelGap: number;
        tickLabelFormatter: (v: number) => string;
        forceTopOverhangHeight: "none" | number;
    };
    axisStrokeWidth: number;
    gridStrokeWidth: number;
    colGroupBracketStrokeWidth: number;
    axisColor: string;
    gridColor: string;
    colGroupBracketColor: string;
    backgroundColor: string | "none";
    textAxisTickLabelFormatter: (v: string) => string;
    dataLabelFormatter: CsvCellFormatterFunc<number, string>;
    dataLabelPositions: CsvCellFormatterFunc<number, DataLabelPositionOffset> | undefined;
    arrowLabelFormatter: CsvCellFormatterFunc<number, string>;
    dataLabelGapYPoints: number;
    dataLabelGapXPoints: number;
    dataLabelGapYBars: number;
    dataLabelGapXBars: number;
    dataLabelOffsetXBars: number;
    dataLabelPositionVerticalScale: "alternating" | "left" | "right";
    dataLabelPositionHorizontalScale: "alternating" | "top" | "bottom";
    dataLabelPositionTwoWayScale: "left" | "right" | "top" | "bottom";
    pctOfCol: number;
    pctOfSeries: number;
    stacked: "not-stacked" | "stacked" | "imposed";
    horizontal: boolean;
    withBars: boolean;
    withOutline: boolean;
    withDataLabels: boolean;
    barOpacity: number;
    pointRadius: number;
    pointStrokeWidth: number;
    pointInnerColorStrategy: ColorAdjustmentStrategy;
    errorBarColorStrategy: ColorAdjustmentStrategy;
    errorBarWidthProportionOfPoint: number;
    errorBarWidthProportionOfBar: number;
    withArrows: boolean | StyleFuncBoolean;
    arrowGap: number;
    arrowLength: number;
    arrowLabelGap: number;
    arrowColor: string;
    cascadeArrows: {
        showArrows: boolean | StyleFuncBoolean;
        arrowColor: StyleFuncString;
        arrowLabelFormatter: CsvCellFormatterFunc<number, string>;
        arrowStrokeWidth: number;
        arrowLengthPctOfSpace: number;
        arrowHeadLength: number;
        arrowLabelGap: number;
        upperLabels: "none" | StyleFuncUpperLabel;
        upperLabelWidthPctOfCol: number;
        upperLabelGapFromChartAreaY: number;
    };
    outlineOpacity: number;
    getOutlineOpacity: "none" | ((index: number) => number);
    outlineType: "straight" | "curved" | "rounded";
    outlineRoundedRadius: number;
    getOutlineWidth: "none" | ((index: number) => number);
};
export type MergedSurroundsStyle = {
    padding: Padding;
    text: {
        caption: TextInfoUnkeyed;
        footnote: TextInfoUnkeyed;
    };
    captionGap: number;
    footnoteGap: number;
    legendGap: number;
    legendPosition: LegendPosition;
};
export type MergedLegendStyle = {
    text: TextInfoUnkeyed;
    maxLegendItemsInOneColumn: number | number[];
    legendColorBoxWidth: number;
    legendItemVerticalGap: number;
    legendLabelGap: number;
    legendPointRadius: number;
    legendPointStrokeWidth: number;
    legendPointInnerColorStrategy: ColorAdjustmentStrategy;
    reverseOrder: boolean;
};
export type MergedPaletteColorStyle = {
    logic: PaletteLogic;
    single: ColorKeyOrString;
    specific: ColorKeyOrString[];
    auto: {
        first: ColorKeyOrString;
        last: ColorKeyOrString;
    };
    func: StyleFuncColorKeyOrString;
};
export type MergedPalettePointStylesStyle = {
    logic: PaletteLogic;
    single: PointStyle;
    specific: PointStyle[];
    auto: PointStyle[];
};
export type MergedMultiContentStyle = {
    alreadyScaledValue: number;
    logicContentHeights: "equal" | "specific";
    padding: Padding;
    backgroundColor: string;
    text: {
        subCaption: TextInfoUnkeyed;
    };
    subChartGapX: number;
    subChartGapY: number;
    nPerRow: number;
    nSlotsToSkip: number;
    subCaptionGap: number;
};
