import type { PointEstimateBounds } from "./types";
export type CsvOptions<T> = {
    colHeaders?: "none" | string[];
    rowHeaders?: "none" | string[];
    aoa?: T[][];
};
type RowFilterFunc<T> = (row: T[], i_row: number, csv: Csv<T>) => boolean;
type RowFindFunc<T> = (row: T[], i_row: number, csv: Csv<T>) => boolean;
export declare class Csv<T> {
    private _colHeaders;
    private _rowHeaders;
    private _aoa;
    constructor(opts?: Csv<T> | CsvOptions<T> | string[]);
    static fromString(str: string, opts?: {
        colHeaders?: "none" | "use-first-row";
        rowHeaders?: "none" | "use-first-col";
    }): Csv<string>;
    static fromAoA(rawAoa: string[][], opts?: {
        colHeaders?: "none" | "use-first-row";
        rowHeaders?: "none" | "use-first-col";
    }): Csv<string>;
    static fromObjectArray(arr: Record<string, unknown>[]): Csv<string>;
    dataType(): "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";
    colHeaders(): "none" | string[];
    rowHeaders(): "none" | string[];
    colHeadersOrThrowIfNone(): string[];
    rowHeadersOrThrowIfNone(): string[];
    aoa(): T[][];
    nCols(): number;
    nRows(): number;
    getColHeaderIndex(numberOrHeader: number | string): number;
    getRowHeaderIndex(numberOrHeader: number | string | RowFindFunc<T>): number;
    getColHeaderIndexes(numbersOrHeaders: number[] | string[]): number[];
    getRowHeaderIndexes(numbersOrHeaders: number[] | string[] | RowFilterFunc<T>): number[];
    private getHeaderIndexes;
    private getHeaderIndex;
    forEachRow(func: (row: T[], i_row: number, csv: Csv<T>) => void): void;
    assertNumberCsv(): asserts this is Csv<number>;
    assertStringCsv(): asserts this is Csv<string>;
    validate(): void;
    validateColIndex(colIndex: number): void;
    validateColHeader(colHeader: string): void;
    validateRowIndex(rowIndex: number): void;
    validateRowHeader(rowHeader: string): void;
    MUTATE_updateColHeaders(newColHeaders: string[] | "none"): void;
    withUpdatedColHeaders(newColHeaders: string[] | "none"): Csv<T>;
    withMappedColHeaders(func: (colHeader: string, i_colHeader: number) => string): Csv<T>;
    MUTATE_updateRowHeaders(newRowHeaders: string[] | "none"): void;
    withUpdatedRowHeaders(newRowHeaders: string[] | "none"): Csv<T>;
    withMappedRowHeaders(func: (rowHeader: string, i_rowHeader: number) => string): Csv<T>;
    withColAsRowHeaders(colNumberOrHeader: number | string): Csv<T>;
    MUTATE_updateCol(colNumberOrHeader: number | string, mapFunc: (cell: T, row: T[], csv: Csv<T>) => T): void;
    MUTATE_addRow(rowOrRowVal: T | T[], rowHeader?: string): void;
    withAddedRow(rowOrRowVal: T | T[], rowHeader?: string): Csv<T>;
    MUTATE_addRows(nRows: number, func: (index: number) => {
        row: T[];
        rowHeader?: string;
    }): void;
    withAddedRows(nRows: number, func: (index: number) => {
        row: T[];
        rowHeader?: string;
    }): Csv<T>;
    MUTATE_addCol(colOrColVal: T | T[], colHeader?: string): void;
    withAddedCol(colOrColVal: T | T[], colHeader?: string): Csv<T>;
    withTotalRowAndColumn(): Csv<number>;
    MUTATE_removeCol(colNumberOrHeader: number | string): void;
    withRemovedCol(colNumberOrHeader: number | string): Csv<T>;
    getCellVal(colNumberOrHeader: number | string, rowNumberOrHeader: number | string): T;
    getCellValRowFilterFunc(colNumberOrHeader: number | string, rowIndexFindIndexFunc: RowFilterFunc<T>): T;
    getColVals(colNumberOrHeader: number | string): T[];
    getColValsWithFilter(colNumberOrHeader: number | string, filterFunc: RowFilterFunc<T>): T[];
    getColValsAsUniqueAndSortedArrayOfStrings(colNumberOrHeader: number | string): string[];
    getRowVals(rowNumberOrHeader: number | string): T[];
    getCopy(): Csv<T>;
    getAsObject(): {
        colHeaders: "none" | string[];
        rowHeaders: "none" | string[];
        aoa: T[][];
    };
    getNumbers(): Csv<number>;
    getStrings(): Csv<string>;
    getMappedCells<R>(func: (cell: T, i_row: number, i_cell: number, csv: Csv<T>) => R): Csv<R>;
    getMappedRows<R>(func: (row: T[], i_row: number, csv: Csv<T>) => R[]): Csv<R>;
    getCompleteAoA(colHeaderForNewFirstCol?: string): (T | string)[][];
    stringify(): string;
    getAsObjectArray(colHeadersToTake?: string[]): Record<string, T>[];
    getRowsAsMappedArray<R>(func: (row: T[], i_row: number, csv: Csv<T>) => R): R[];
    getSingleRowAsObjectWithColHeadersAsProps(rowNumberOrHeader: number | string | RowFindFunc<T>): Record<string, T>;
    getSingleColAsObjectWithRowHeadersAsProps(colNumberOrHeader: number | string): Record<string, T>;
    getAsObjectWithRowHeadersAsProps<R>(func: (row: T[], i_row: number, csv: Csv<T>) => R): Record<string, R>;
    getAsNestedObjectWithRowHeadersAsFirstLevelPropsAndColHeadersAsSecondLevelProps(): Record<string, Record<string, T>>;
    getTransposed(transpose?: boolean): Csv<T>;
    getSelectedCols(colsToTake: number[] | string[] | undefined): Csv<T>;
    getSelectedRows(rowsToTake: number[] | string[] | RowFilterFunc<T> | undefined): Csv<T>;
    getSortedRowsByCol(col: number | string | undefined, directionOrSortFunc?: "descending" | "ascending" | ((a: T, b: T) => number)): Csv<T>;
    getSortedColsByRow(row: number | string | undefined, directionOrSortFunc?: "descending" | "ascending" | ((a: T, b: T) => number)): Csv<T>;
    orderCols(colNumbersOrHeaders: string[] | number[]): Csv<T>;
    collapseAllAsNumbers(reducerFunc: (filteredColValues: T[]) => number): Csv<number>;
    collapse(stratifierColNumbersOrHeaders: string[] | number[], reducerFuncs: {
        colNumbersOrHeaders: string[] | number[];
        reducerFunc: (filteredColValues: T[]) => string;
    }[]): Csv<string>;
    joinColsWithRowsSameOrder(otherCsv: Csv<T>): Csv<T>;
    joinColsWithMatchedRowHeaders(otherCsv: Csv<T>): Csv<T>;
    joinRowsWithMatchedColHeaders(otherCsv: Csv<T>): Csv<T>;
    reshapeWide(colNumberOrHeaderFromWhichToCreateCols: number | string, colNumberOrHeaderFromWhichToCreateRows: number | string, colNumberOrHeaderForVals: number | string): Csv<T>;
    getWithPointEstimateBounds<T extends "none" | "from-adjacent-cols" | "from-adjacent-rows" | undefined, R = T extends undefined ? Csv<T> : Csv<PointEstimateBounds>>(from: T): R;
    print(nRows?: number): void;
    write(writerFunc: (str: string) => void): void;
}
export {};
